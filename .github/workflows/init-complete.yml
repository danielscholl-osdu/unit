name: Initialize Complete

on:
  issue_comment:
    types: [created]

permissions:
  contents: write
  actions: write
  issues: write
  pull-requests: write

concurrency:
  group: ${{ github.workflow }}-${{ github.event.issue.number }}
  cancel-in-progress: false

jobs:
  validate_and_setup:
    name: Validate and setup repository
    if: |
      github.event.issue.state == 'open' &&
      contains(github.event.issue.labels.*.name, 'initialization') &&
      github.event.comment.user.login != 'github-actions[bot]' &&
      vars.IS_TEMPLATE != 'true'
    runs-on: ubuntu-latest
    outputs:
      upstream_repo: ${{ steps.validate.outputs.upstream_repo }}
      should_proceed: ${{ steps.validate.outputs.should_proceed }}
    steps:
      - name: Template Repository Protection Check
        run: |
          if [[ "${{ vars.IS_TEMPLATE }}" == "true" ]]; then
            echo "🛡️ BLOCKED: This workflow is blocked in template development repositories"
            echo "The IS_TEMPLATE variable is set to 'true', which prevents initialization workflows from running."
            echo "This is a safety mechanism to prevent accidental initialization of the template repository itself."
            echo ""
            echo "If you're trying to test initialization:"
            echo "1. Create a test repository from this template"
            echo "2. Run the initialization workflow in that repository instead"
            exit 1
          fi
          echo "✅ Safety check passed - proceeding with initialization"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Validate
        id: validate
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get the comment body and clean it
          COMMENT="${{ github.event.comment.body }}"
          REPO=$(echo "$COMMENT" | head -1 | xargs)
          
          echo "Processing comment: $REPO"
          
          # Validate repository format
          if [[ "$REPO" == http* ]]; then
            # GitLab URL format validation
            if ! [[ "$REPO" =~ ^https?://[^/]+/[^/]+/[^/]+(/.*)?$ ]]; then
              echo "❌ Invalid GitLab URL format: $REPO" | gh issue comment "${{ github.event.issue.number }}" --body-file -
              echo "should_proceed=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          else
            # GitHub owner/repo format validation
            if ! [[ "$REPO" =~ ^[A-Za-z0-9_.-]+/[A-Za-z0-9_.-]+$ ]]; then
              echo "❌ Invalid repository format. Expected 'owner/repo' but got '$REPO'" | gh issue comment "${{ github.event.issue.number }}" --body-file -
              echo "should_proceed=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          echo "upstream_repo=$REPO" >> $GITHUB_OUTPUT
          echo "should_proceed=true" >> $GITHUB_OUTPUT
          
          # Post confirmation
          cat << EOF | gh issue comment "${{ github.event.issue.number }}" --body-file -
          ✅ **Repository validated:** \`$REPO\`

          🔄 **Starting initialization process...**

          This will take a few minutes. I'll update you with progress!
          EOF

      - name: Set UPSTREAM_REPO_URL Variable
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          REPO="${{ steps.validate.outputs.upstream_repo }}"
          if [[ "$REPO" == http* ]]; then
            REPO_URL="$REPO.git"
          else
            REPO_URL="https://github.com/$REPO.git"
          fi
          echo "Setting UPSTREAM_REPO_URL variable to: $REPO_URL"
          echo "URL length: ${#REPO_URL}"
          if [ -n "$GH_TOKEN" ]; then
            if ! GH_TOKEN=$GH_TOKEN gh variable set UPSTREAM_REPO_URL --body "$REPO_URL"; then
              echo "Failed to set UPSTREAM_REPO_URL variable"
            fi
          else
            echo "GH_TOKEN not available, skipping variable configuration"
          fi

  setup_repository:
    name: Setup Repository
    needs: validate_and_setup
    if: needs.validate_and_setup.outputs.should_proceed == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config pull.rebase false

      - name: Upstream Repository
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          UPSTREAM_REPO: ${{ needs.validate_and_setup.outputs.upstream_repo }}
        run: |
          # Convert to URL format
          if [[ "$UPSTREAM_REPO" == http* ]]; then
            REPO_URL="$UPSTREAM_REPO.git"
          else
            REPO_URL="https://github.com/$UPSTREAM_REPO.git"
          fi

          # Store repo URL for use in subsequent steps
          echo "REPO_URL=$REPO_URL" >> $GITHUB_ENV
          
          # Add upstream remote
          git remote add upstream $REPO_URL
          git fetch upstream --prune --tags
          
          # Get all branches from upstream
          BRANCHES=$(git branch -r | grep upstream | sed 's/upstream\///' | grep -v HEAD | tr '\n' ' ')
          echo "Available branches: $BRANCHES"
          
          # Determine default branch
          if git rev-parse --verify upstream/main >/dev/null 2>&1; then
            DEFAULT_BRANCH="main"
          elif git rev-parse --verify upstream/master >/dev/null 2>&1; then
            DEFAULT_BRANCH="master"
          else
            # Try to detect default branch from HEAD
            DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/upstream/HEAD 2>/dev/null | sed 's@^refs/remotes/upstream/@@')
            
            if [ -z "$DEFAULT_BRANCH" ]; then
              # Last resort: check common branch names
              for branch in develop development prod production release stable; do
                if git rev-parse --verify upstream/$branch >/dev/null 2>&1; then
                  DEFAULT_BRANCH="$branch"
                  break
                fi
              done
            fi
            
            if [ -z "$DEFAULT_BRANCH" ]; then
              echo "❌ **Error:** Could not determine default branch in upstream repository" | gh issue comment "${{ github.event.issue.number }}" --body-file -
              echo "Available branches found: $BRANCHES" | gh issue comment "${{ github.event.issue.number }}" --body-file -
              echo "Please ensure the upstream repository has at least one branch." | gh issue comment "${{ github.event.issue.number }}" --body-file -
              exit 1
            fi
          fi
          
          echo "✅ Using default branch: $DEFAULT_BRANCH" | gh issue comment "${{ github.event.issue.number }}" --body-file -
          echo "DEFAULT_BRANCH=$DEFAULT_BRANCH" >> $GITHUB_ENV
          
      - name: Configure Variables
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
          REPO_URL: ${{ env.REPO_URL }}
        run: |
          # Set repository variables using GH_TOKEN
          VARIABLES_SUCCESS=true
          if [ -n "$GH_TOKEN" ]; then
            echo "Setting UPSTREAM_REPO_URL variable to: $REPO_URL"
            echo "URL length: ${#REPO_URL}"
            if ! GH_TOKEN=$GH_TOKEN gh variable set UPSTREAM_REPO_URL --body "$REPO_URL"; then
              echo "Failed to set UPSTREAM_REPO_URL variable"
              VARIABLES_SUCCESS=false
            fi
            
            # Configure GitHub Copilot firewall allowlist if configuration exists
            if [ -f ".github/fork-resources/copilot-firewall-config.json" ]; then
              echo "Configuring GitHub Copilot firewall allowlist..."
              FIREWALL_DOMAINS=$(jq -r '.firewall_additions | join(",")' .github/fork-resources/copilot-firewall-config.json)
              if [ -n "$FIREWALL_DOMAINS" ] && [ "$FIREWALL_DOMAINS" != "null" ]; then
                echo "Setting COPILOT_AGENT_FIREWALL_ALLOW_LIST_ADDITIONS to: $FIREWALL_DOMAINS"
                if ! GH_TOKEN=$GH_TOKEN gh variable set COPILOT_AGENT_FIREWALL_ALLOW_LIST_ADDITIONS --body "$FIREWALL_DOMAINS"; then
                  echo "Failed to set COPILOT_AGENT_FIREWALL_ALLOW_LIST_ADDITIONS variable"
                  VARIABLES_SUCCESS=false
                fi
              fi
            fi
          else
            echo "GH_TOKEN not available, skipping variable configuration"
            VARIABLES_SUCCESS=false
          fi
          echo "VARIABLES_SUCCESS=$VARIABLES_SUCCESS" >> $GITHUB_ENV

      - name: Branch Structure
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          # Check if this is an OSDU partition repository (for debugging)
          if [[ "${{ needs.validate_and_setup.outputs.upstream_repo }}" == *"partition"* ]]; then
            # List release branches for OSDU repos (internal logging only)
            RELEASE_BRANCHES=$(git branch -r | grep upstream/release | sed 's/upstream\///' | tr '\n' ', ')
            if [ -n "$RELEASE_BRANCHES" ]; then
              echo "Debug: Found release branches: $RELEASE_BRANCHES"
            fi
          fi
          
          # Create fork_upstream from upstream's default branch
          git checkout -b fork_upstream upstream/$DEFAULT_BRANCH
          
          # Try to push with error handling for push protection
          echo "::notice::Pushing fork_upstream branch..."
          
          # Capture both stdout and stderr, and preserve exit code
          set +e  # Don't exit on command failure
          git push -u origin fork_upstream 2>&1 | tee push_output.txt
          PUSH_EXIT_CODE=${PIPESTATUS[0]}
          set -e  # Re-enable exit on error
          
          if [ $PUSH_EXIT_CODE -ne 0 ]; then
            if grep -q "GH013: Repository rule violations found" push_output.txt; then
              echo "::error::Push blocked by push protection due to secrets"
              
              # Extract secret allowlist URLs (improved regex to handle ANSI codes)
              SECRETS_INFO=$(grep -Eo 'https://github\.com/.+/secret-scanning/unblock-secret/[A-Za-z0-9]+' \
                             push_output.txt | head -20)
              
              # Extract blob IDs (corrected pattern: GitHub uses "blob id: " with space)
              BLOB_IDS=$(grep -Eo 'blob id: *[a-f0-9]+' push_output.txt \
                         | sed -E 's/^blob id: *//' | head -20)
              
              # Create detailed issue with resolution steps
              ISSUE_BODY="## 🔒 Push Protection Blocking Initialization\n\n"
              ISSUE_BODY="${ISSUE_BODY}The initialization workflow was blocked by push protection. This is likely due to secrets detected in the upstream repository's git history.\n\n"
              ISSUE_BODY="${ISSUE_BODY}### Detected Issues\n\n"
              
              if [ -n "$BLOB_IDS" ]; then
                ISSUE_BODY="${ISSUE_BODY}### Detected Secret Blob IDs\n\`\`\`\n${BLOB_IDS}\n\`\`\`\n\n"
              fi
              
              ISSUE_BODY="${ISSUE_BODY}### Resolution Options\n\n"
              ISSUE_BODY="${ISSUE_BODY}1. **✅ Recommended: Use Secret Allowlist URLs** (Manual Process)\n"
              ISSUE_BODY="${ISSUE_BODY}   - **Important**: This requires manual action - GitHub requires human approval for security\n"
              ISSUE_BODY="${ISSUE_BODY}   - Click each URL below in your browser while logged into GitHub\n"
              ISSUE_BODY="${ISSUE_BODY}   - Review each secret and click \"Allow secret\" if it's safe to include\n"
              ISSUE_BODY="${ISSUE_BODY}   - After allowing all secrets, comment the upstream repo URL on the original issue to re-run initialization\n\n"
              
              if [ -n "$SECRETS_INFO" ]; then
                ISSUE_BODY="${ISSUE_BODY}   **Secret Allowlist URLs** (click each one):\n"
                while IFS= read -r url; do
                  [ -n "$url" ] && ISSUE_BODY="${ISSUE_BODY}   - [Allow Secret](${url})\n"
                done <<< "$SECRETS_INFO"
              else
                ISSUE_BODY="${ISSUE_BODY}   ⚠️ No allowlist URLs detected in output - check workflow logs\n"
              fi
              
              ISSUE_BODY="${ISSUE_BODY}\n2. **Alternative: Organization Admin Action**\n"
              ISSUE_BODY="${ISSUE_BODY}   - Ask your organization admin to temporarily disable push protection\n"
              ISSUE_BODY="${ISSUE_BODY}   - Re-run the initialization after it's disabled\n"
              ISSUE_BODY="${ISSUE_BODY}   - Re-enable push protection after initialization completes\n\n"
              
              ISSUE_BODY="${ISSUE_BODY}3. **Manual Initialization**\n"
              ISSUE_BODY="${ISSUE_BODY}   - Clone the repository locally\n"
              ISSUE_BODY="${ISSUE_BODY}   - Run the initialization steps manually\n"
              ISSUE_BODY="${ISSUE_BODY}   - Use \`git push --no-verify\` if you have appropriate permissions\n\n"
              
              ISSUE_BODY="${ISSUE_BODY}### Workflow Run\n"
              ISSUE_BODY="${ISSUE_BODY}[View workflow logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})\n\n"
              
              ISSUE_BODY="${ISSUE_BODY}### Next Steps\n"
              ISSUE_BODY="${ISSUE_BODY}After resolving the push protection issue using one of the methods above, please:\n"
              ISSUE_BODY="${ISSUE_BODY}1. Close this issue\n"
              ISSUE_BODY="${ISSUE_BODY}2. Re-run the initialization by commenting the upstream repository URL on the original initialization issue"
              
              # Create issue with improved content and capture the URL
              ESCALATION_ISSUE_URL=$(printf "%b" "$ISSUE_BODY" | gh issue create \
                --title "🔒 Push Protection Blocking Initialization - Action Required" \
                --body-file - \
                --label "initialization,escalation") || true
              
              # Also comment on the original issue with link to escalation issue
              if [ -n "$ESCALATION_ISSUE_URL" ]; then
                COMMENT_MSG="❌ **Initialization blocked by push protection**\n\nThe upstream repository contains secrets that are being blocked by GitHub's push protection.\n\n**Next Steps:**\n1. 📋 I've created a detailed issue with allowlist URLs: $ESCALATION_ISSUE_URL\n2. 🔓 Visit each allowlist URL and click 'Allow secret'\n3. 🔄 Re-run initialization by commenting \`${{ needs.validate_and_setup.outputs.upstream_repo }}\` again\n\nThe second run will succeed once secrets are allowlisted!"
              else
                COMMENT_MSG="❌ **Initialization blocked by push protection**\n\nThe upstream repository contains secrets that are being blocked by GitHub's push protection.\n\n**Next Steps:**\n1. 📋 I've created a detailed issue with allowlist URLs - check issues labeled 'escalation'\n2. 🔓 Visit each allowlist URL and click 'Allow secret'\n3. 🔄 Re-run initialization by commenting \`${{ needs.validate_and_setup.outputs.upstream_repo }}\` again\n\nThe second run will succeed once secrets are allowlisted!"
              fi
              printf "%b" "$COMMENT_MSG" | gh issue comment "${{ github.event.issue.number }}" --body-file -
              
              exit 1
            else
              # Some other push error
              echo "::error::Push failed for unknown reason:"
              cat push_output.txt
              exit 1
            fi
          else
            echo "::notice::Successfully pushed fork_upstream branch"
          fi
          
          # Create fork_integration from fork_upstream
          git checkout -b fork_integration fork_upstream
          
          # Copy files according to sync configuration
          # First, get the sync configuration
          git checkout main -- .github/sync-config.json
          
          # Copy directories that should be synced entirely
          DIRECTORIES=$(jq -r '.sync_rules.directories[] | .path' .github/sync-config.json)
          for dir in $DIRECTORIES; do
            echo "Copying directory: $dir"
            git checkout main -- "$dir/" || echo "Directory $dir not found, skipping"
          done
          
          # Copy individual files
          FILES=$(jq -r '.sync_rules.files[] | .path' .github/sync-config.json)
          for file in $FILES; do
            echo "Copying file: $file"
            git checkout main -- "$file" || echo "File $file not found, skipping"
          done
          
          # Add template remote to be able to track template updates
          TEMPLATE_REPO_URL="${{ vars.TEMPLATE_REPO_URL || 'https://github.com/danielscholl-osdu/osdu-fork-template.git' }}"
          git remote add template "$TEMPLATE_REPO_URL" || true
          git fetch template main --depth=1
          
          # Copy fork workflows from template repository
          # This must happen before merge to avoid GitHub App workflow permission issues
          echo "Copying fork-specific workflows from template repository..."
          git checkout template/main -- .github/template-workflows/
          if [ -d ".github/template-workflows" ]; then
            # Ensure workflows directory exists
            mkdir -p .github/workflows
            cp .github/template-workflows/*.yml .github/workflows/
            echo "Copied workflows:"
            ls .github/template-workflows/*.yml | xargs -I {} basename {}
          else
            echo "⚠️ Warning: .github/template-workflows directory not found in template"
          fi
          
          # Initialize tracking files
          TRACKING_FILES=$(jq -r '.sync_rules.tracking_files[] | select(.auto_create == true) | .path' .github/sync-config.json)
          for tracking_file in $TRACKING_FILES; do
            echo "Initializing tracking file: $tracking_file"
            mkdir -p "$(dirname "$tracking_file")"
            
            # Special handling for template sync commit file
            if [[ "$tracking_file" == ".github/.template-sync-commit" ]]; then
              # We need to find the template commit that matches our current template files
              # Since we just created this from the template, we can use the template's current HEAD
              # But ideally we'd want the exact commit this was forked from
              # For now, use the current template HEAD as baseline (may include some changes we already have)
              TEMPLATE_BASELINE=$(git rev-parse template/main)
              echo "$TEMPLATE_BASELINE" > "$tracking_file"
              echo "Initialized $tracking_file with template commit: $TEMPLATE_BASELINE"
            else
              # For other tracking files, create empty
              echo "" > "$tracking_file"
            fi
            
            git add "$tracking_file"
          done
          
          # Commit all copied files including workflows
          git add .github
          git commit -m "chore: copy configuration and workflows from main branch"
          
          # Push fork_integration with error handling
          echo "::notice::Pushing fork_integration branch..."
          set +e
          git push -u origin fork_integration 2>&1 | tee push_integration_output.txt
          PUSH_INTEGRATION_EXIT_CODE=${PIPESTATUS[0]}
          set -e
          
          if [ $PUSH_INTEGRATION_EXIT_CODE -ne 0 ]; then
            if grep -q "GH013: Repository rule violations found" push_integration_output.txt; then
              echo "::error::fork_integration push also blocked by push protection"
              echo "::notice::This is expected if the upstream repository contains secrets"
              echo "::notice::The same allowlist URLs from the previous error will resolve this issue"
              exit 1
            else
              echo "::error::fork_integration push failed for unknown reason:"
              cat push_integration_output.txt
              exit 1
            fi
          else
            echo "::notice::Successfully pushed fork_integration branch"
          fi

      - name: Merge to Main
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          # Merge fork_integration into main with conflict resolution
          git checkout main
          
          # Try merge with unrelated histories, preferring fork_integration changes
          if ! git merge fork_integration --allow-unrelated-histories --no-ff -X theirs -m "chore: complete repository initialization"; then
            echo "⚠️ **Merge conflicts detected, resolving automatically...**" | gh issue comment "${{ github.event.issue.number }}" --body-file -
            
            # If there are still conflicts even with -X theirs, explicitly take fork_integration version
            git status --porcelain | grep -E '^(DD|AU|UD|UA|DU|AA|UU)' | cut -c4- | while read -r file; do
              echo "Resolving conflict in $file - using upstream version"
              # Use the version from fork_integration (which comes from upstream)
              git checkout --theirs "$file"
              git add "$file"
            done
            
            # Complete the merge
            git commit -m "chore: complete repository initialization (conflicts resolved using upstream versions)"
          fi
          
          # Copy fork-specific resources before cleanup
          echo "Copying fork-specific resources..."
          
          # Copy fork-specific copilot instructions
          if [ -f ".github/fork-resources/copilot-instructions.md" ]; then
            echo "Installing fork-specific copilot instructions..."
            cp ".github/fork-resources/copilot-instructions.md" ".github/copilot-instructions.md"
            git add ".github/copilot-instructions.md"
          fi
          
          
          # Copy GitHub Copilot firewall configuration
          if [ -f ".github/fork-resources/copilot-firewall-config.json" ]; then
            echo "Installing GitHub Copilot firewall configuration..."
            cp ".github/fork-resources/copilot-firewall-config.json" ".github/copilot-firewall-config.json"
            git add ".github/copilot-firewall-config.json"
          fi
          
          # Copy triage prompt file to .github/prompts directory
          if [ -f ".github/fork-resources/triage.prompt.md" ]; then
            echo "Installing triage prompt for dependency analysis..."
            mkdir -p ".github/prompts"
            cp ".github/fork-resources/triage.prompt.md" ".github/prompts/triage.prompt.md"
            git add ".github/prompts/triage.prompt.md"
          fi
          
          # Copy .vscode configuration directory
          if [ -d ".github/fork-resources/.vscode" ]; then
            echo "Installing .vscode MCP configuration..."
            mkdir -p ".vscode"
            cp -r ".github/fork-resources/.vscode/"* ".vscode/"
            # Force add .vscode files even if gitignore might affect them
            git add -f ".vscode/"
          fi
          
          # Copy issue templates
          if [ -d ".github/fork-resources/ISSUE_TEMPLATE" ]; then
            echo "Installing fork-specific issue templates..."
            mkdir -p ".github/ISSUE_TEMPLATE"
            cp -r ".github/fork-resources/ISSUE_TEMPLATE/"* ".github/ISSUE_TEMPLATE/"
            git add ".github/ISSUE_TEMPLATE/"
          fi
          
          # Copy copilot setup steps workflow
          if [ -f ".github/fork-resources/copilot-setup-steps.yml" ]; then
            echo "Installing GitHub Copilot setup steps workflow..."
            mkdir -p ".github/workflows"
            cp ".github/fork-resources/copilot-setup-steps.yml" ".github/workflows/copilot-setup-steps.yml"
            git add ".github/workflows/copilot-setup-steps.yml"
          fi
          
          # Clean up fork-resources directory after copying
          if [ -d ".github/fork-resources" ]; then
            echo "Removing fork-resources directory after copying..."
            rm -rf ".github/fork-resources"
          fi
          
          # Clean up template development workflows and template-workflows directory
          echo "Cleaning up template development workflows..."
          
          # Remove all dev-* workflows (template development only)
          echo "Removing template development workflows..."
          rm -f .github/workflows/dev-*.yml
          
          # Remove the template-workflows directory (no longer needed)
          echo "Cleaning up template-workflows directory..."
          rm -rf .github/template-workflows/
          
          # Clean up template files using sync configuration
          echo "Cleaning up remaining template-specific files..."
          
          # Read cleanup rules from sync configuration
          SYNC_CONFIG=".github/sync-config.json"
          
          # Remove directories specified in cleanup rules
          CLEANUP_DIRS=$(jq -r '.cleanup_rules.directories[]? | .path' "$SYNC_CONFIG" 2>/dev/null || echo "")
          for dir in $CLEANUP_DIRS; do
            if [ -d "$dir" ]; then
              echo "Removing template directory: $dir"
              rm -rf "$dir"
            fi
          done
          
          # Remove files specified in cleanup rules
          CLEANUP_FILES=$(jq -r '.cleanup_rules.files[]? | .path' "$SYNC_CONFIG" 2>/dev/null || echo "")
          for file in $CLEANUP_FILES; do
            if [ -f "$file" ]; then
              echo "Removing template file: $file"
              rm -f "$file"
            fi
          done
          
          # Remove workflows specified in cleanup rules
          CLEANUP_WORKFLOWS=$(jq -r '.cleanup_rules.workflows[]? | .path' "$SYNC_CONFIG" 2>/dev/null || echo "")
          for workflow in $CLEANUP_WORKFLOWS; do
            if [ -f "$workflow" ]; then
              echo "Removing initialization workflow: $workflow"
              rm -f "$workflow"
            fi
          done
          
          # Add cleanup to the merge commit if there are changes
          git add -A
          if ! git diff --staged --quiet; then
            git commit --amend --no-edit
          fi
          
          git push origin main
          
          # Set repository variable for initialization status
          if [ -n "$GH_TOKEN" ]; then
            GH_TOKEN=$GH_TOKEN gh variable set INITIALIZATION_COMPLETE --body "true"
          fi

      - name: Branch Protection
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          BRANCH_PROTECTION_SUCCESS=true
          
          # Try to create branch protection rules
          if [ -n "$GH_TOKEN" ]; then
            # Use PAT for branch protection
            for branch in main fork_upstream fork_integration; do
              if ! GH_TOKEN=$GH_TOKEN gh api \
                --method PUT \
                -H "Accept: application/vnd.github.v3+json" \
                "/repos/${{ github.repository }}/branches/$branch/protection" \
                --input - << 'EOF'
          {
            "required_status_checks": {
              "strict": true,
              "contexts": []
            },
            "enforce_admins": false,
            "required_pull_request_reviews": {
              "required_approving_review_count": 1,
              "dismiss_stale_reviews": true
            },
            "restrictions": null,
            "allow_force_pushes": false,
            "allow_deletions": false
          }
          EOF
              then
                echo "⚠️ Failed to protect branch $branch"
                BRANCH_PROTECTION_SUCCESS=false
              fi
            done
          else
            echo "⚠️ **Warning:** Unable to set branch protection rules. Please configure manually or provide a GH_TOKEN secret with appropriate permissions." | gh issue comment "${{ github.event.issue.number }}" --body-file -
            echo "To set up branch protection manually, go to Settings → Branches for each of: main, fork_upstream, fork_integration" | gh issue comment "${{ github.event.issue.number }}" --body-file -
            BRANCH_PROTECTION_SUCCESS=false
          fi
          
          echo "BRANCH_PROTECTION_SUCCESS=$BRANCH_PROTECTION_SUCCESS" >> $GITHUB_ENV

      - name: Configure Security
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          SECURITY_SUCCESS=true
          
          # Enable security features if possible
          if [ -f .github/security-on.json ]; then
            if [ -n "$GH_TOKEN" ]; then
              if ! GH_TOKEN=$GH_TOKEN gh api \
                --method PATCH \
                -H "Accept: application/vnd.github.v3+json" \
                "/repos/${{ github.repository }}" \
                --input .github/security-on.json; then
                echo "⚠️ Some security features may require manual configuration"
                SECURITY_SUCCESS=false
              fi
            else
              echo "⚠️ **Note:** Security features require manual configuration. Go to Settings → Security & analysis" | gh issue comment "${{ github.event.issue.number }}" --body-file -
              SECURITY_SUCCESS=false
            fi
          fi
          
          echo "SECURITY_SUCCESS=$SECURITY_SUCCESS" >> $GITHUB_ENV

      - name: Update Status
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Build completion message based on actual success/failure
          if [ "$BRANCH_PROTECTION_SUCCESS" = "true" ]; then
            PROTECTION_STATUS="✅ **Branch Protection:** All branches are protected with PR requirements"
          else
            PROTECTION_STATUS="⚠️ **Branch Protection:** Requires manual setup"
          fi
          
          if [ "$VARIABLES_SUCCESS" = "true" ]; then
            VARIABLE_STATUS="✅ **Repository Variables:** UPSTREAM_REPO_URL and GitHub Copilot firewall allowlist configured"
          else
            VARIABLE_STATUS="⚠️ **Repository Variables:** Requires manual setup (including Copilot firewall allowlist)"  
          fi
          
          if [ "$SECURITY_SUCCESS" = "true" ]; then
            SECURITY_STATUS="✅ **Security Features:** Secret scanning and dependency updates enabled"
          else
            SECURITY_STATUS="⚠️ **Security Features:** Requires manual setup"
          fi
          
          # Only show manual steps if something actually failed
          MANUAL_STEPS=""
          if [ "$BRANCH_PROTECTION_SUCCESS" != "true" ] || [ "$VARIABLES_SUCCESS" != "true" ] || [ "$SECURITY_SUCCESS" != "true" ]; then
            MANUAL_STEPS="
          ## Manual Configuration Required
          
          Some features require manual setup:"
            
            if [ "$BRANCH_PROTECTION_SUCCESS" != "true" ]; then
              MANUAL_STEPS="$MANUAL_STEPS
          - **Branch Protection:** Go to Settings → Branches for each of: main, fork_upstream, fork_integration"
            fi
            
            if [ "$VARIABLES_SUCCESS" != "true" ]; then
              MANUAL_STEPS="$MANUAL_STEPS
          - **Repository Variables:** Set UPSTREAM_REPO_URL and COPILOT_AGENT_FIREWALL_ALLOW_LIST_ADDITIONS in Settings → Secrets and variables → Actions → Variables"
            fi
            
            if [ "$SECURITY_SUCCESS" != "true" ]; then
              MANUAL_STEPS="$MANUAL_STEPS
          - **Security Features:** Enable in Settings → Security & analysis"
            fi
          fi
          
          cat << EOF | gh issue comment "${{ github.event.issue.number }}" --body-file -
          🎉 **Initialization Complete!**

          Your fork management repository is now ready! Here is what was set up:

          ✅ **Branch Structure:**
          - \`main\` - Your stable development branch
          - \`fork_upstream\` - Tracks upstream changes
          - \`fork_integration\` - Integration and conflict resolution

          $PROTECTION_STATUS

          ✅ **Upstream Connection:** Connected to \`${{ needs.validate_and_setup.outputs.upstream_repo }}\`

          ✅ **Automated Workflows:** Sync, validation, and release workflows are active

          ✅ **AI Enhancement:** GitHub Copilot Agent firewall allowlist configured for OSDU domains
          
          ⚠️ **MCP Configuration:** Maven MCP Server requires manual setup (see new issue created above)

          ✅ **Template Cleanup:** Removed template documentation (upstream README will be used)

          $VARIABLE_STATUS

          $SECURITY_STATUS

          $MANUAL_STEPS

          ## Next Steps

          1. **Review the workflows** in the Actions tab
          2. **Customize the README** with your project-specific information  
          3. **Start developing** by creating feature branches from \`main\`
          4. **Sync with upstream** will happen automatically via the sync workflow

          **Happy coding!** 🚀
          EOF

      - name: Create MCP Configuration Issue
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create issue for manual MCP configuration
          cat << 'EOF' > mcp-setup.md
          # 🤖 Configure MCP Server for GitHub Copilot Agent
          
          To enable the Maven MCP Server for GitHub Copilot Agent in this repository, you need to manually configure it in the repository settings.
          
          ## Configuration Steps
          
          1. **Navigate to Repository Settings**:
             - Go to your repository on GitHub.com
             - Click on **Settings** (you must be a repository admin)
             - In the left sidebar under "Code & automation", click **Copilot** → **Copilot agent**
          
          2. **Add MCP Configuration**:
             - Scroll to the **MCP configuration** section
             - Replace the existing JSON with:
          
          ```json
          {
            "mcpServers": {
              "mvn-mcp-server": {
                "type": "local",
                "command": "uvx",
                "args": [
                  "--from",
                  "git+https://github.com/danielscholl-osdu/mvn-mcp-server@main",
                  "mvn-mcp-server"
                ],
                "env": {},
                "tools": [
                  "*"
                ]
              }
            }
          }
          ```
          
          3. **Save Configuration**:
             - The configuration will be validated when you save
             - If validation passes, the MCP server will be available to GitHub Copilot Agent
          
          ## What This Enables
          
          The Maven MCP Server provides GitHub Copilot Agent with capabilities to:
          - Analyze Maven project structures
          - Understand dependencies and build configurations
          - Provide context-aware assistance for Java/Maven projects
          - Help with build issues and dependency management
          
          ## Verification
          
          After configuration, you can verify the setup by:
          1. Assigning an issue to `@copilot` 
          2. The agent should have enhanced Maven project understanding
          
          ## Manual Configuration Required
          
          ⚠️ **Important**: This configuration cannot be automated via API. Repository administrators must configure it manually in the GitHub UI.
          
          ---
          
          Close this issue after completing the MCP configuration.
          EOF
          
          gh issue create \
            --title "🤖 Configure MCP Server for GitHub Copilot Agent" \
            --body-file mcp-setup.md \
            --label "high-priority,copilot"
            
          echo "Created MCP configuration issue"

      - name: Complete Initialization
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Close the initialization issue
          gh issue close "${{ github.event.issue.number }}" --reason completed